# JOINS & Other Interesting DQL Topics

# Chinook.db schema
Before we sart the class let's take a look at the Chinook.db data model to grab a high level view of what the database looks like:

![chinook](https://schemaspy.org/sample/diagrams/summary/relationships.real.compact.png)

### Key Takeaways:

1. In general data in RDBS are aligned as entities/ tables and as attributes/ columns there in
2. Each table usually maps to a business concept (noun) and each row of data is a instance of the entity
3. Attributes/ Columns hold information that decribe each specific entity
4. Entitie are identified via **primary keys** and related via **foreign keys**
5. Each foreign key relationship is a **word sentence** of a model that SQL queries must conform to
6. Foreign Key relationships enforce business rules:
    - Cardinality: Determines the number of entity instances on one side of the relationship that can be joined to a single entity on the other side( N to 0,1,M)
    - Optionality: Specifies how entity inatance on one side must be joined to an entity on the other side (N=0 or 1)
7. SQL JOINS help us to fetch information across entity tables following the defined business rules
8. GROUP BY clauses are used to **aggregate** information from higher cardinality tables to lower cardinality tables
9. **Granularity** is a measure of the level of detail in a data structure. 
    - InvoiceLine is at the granularity of a Invoice, track and date

| :memo:        | In the following sections we shall use a question answer type format to ask a business question and answer it with a SQL using the chinook.db practise database|
|---------------|:------------------------|

# Set Operations
## UNON
Sometimes, you need to combine data from multiple tables into a complete result set. It may be for tables with similar data within the same database or maybe you need to combine similar data from multiple databases. To combine rows from two or more queries into a single result set, you use SQLite UNION operator.

Both UNION and UNION ALL operators combine rows from result sets into a single result set. The UNION operator removes eliminate duplicate rows, whereas the UNION ALL operator does not.

Because the UNION ALL operator does not remove duplicate rows, it runs faster than the UNION operator.
The following are rules to union data:

- The number of columns in all queries must be the same.
- The corresponding columns must have compatible data types.
- The column names of the first query determine the column names of the combined result set.
- The GROUP BY and HAVING clauses are applied to each individual query, not the final result set.
- The ORDER BY clause is applied to the combined result set, not within the individual result set.

**Note that the difference between UNION and JOIN e.g., INNER JOIN or LEFT JOIN is that the JOIN clause combines columns from multiple related tables, while UNION combines rows from multiple similar tables.**

*Who are all the people in the chinook.db database?*

```sql
SELECT FirstName, LastName, 'Employee' AS Type
FROM employees
UNION
SELECT FirstName, LastName, 'Customer'
FROM customers;
```
*Who are all the people in the chinook.db database, sorted by last name?*

```sql
SELECT FirstName, LastName, 'Employee' AS Type
FROM employees
UNION
SELECT FirstName, LastName, 'Customer'
FROM customers
ORDER BY LastName;
```
## INTERSECT
SQLite INTERSECT operator compares the result sets of two queries and returns distinct rows that are output by both queries.
The basic rules for combining the result sets of two queries are as follows:

- First, the number and the order of the columns in all queries must be the same.
- Second, the data types must be comparable.

```sql
SELECT CustomerId
FROM customers
INTERSECT
SELECT CustomerId
FROM invoices
ORDER BY CustomerId;
```
| :bulb:        | This is akin to a list of CustomerId that can be generated by a INNER JOIN between the two tables!! Why don't you try writing that SQL in the JOINS section |
|---------------|:------------------------|

## EXCEPT
SQLite EXCEPT operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query.
This query must conform to the following rules:
- First, the number of columns in the select lists of both queries must be the same.
- Second, the order of the columns and their types must be comparable.

*What are the artistID that don't have a album to their credit?*
```sql
SELECT ArtistId
FROM artists
EXCEPT
SELECT ArtistId
FROM albums;
```
# JOINS
There are various kinds of SQLite joins to query data from two or more tables. An artist can have zero or many albums while an album belongs to one artist.

To query data from both artists and albums tables, you use can use an INNER JOIN, LEFT JOIN in SQLite

| :memo:        | As indicated earlier SQLite doesn‚Äôt directly support the RIGHT JOIN and FULL OUTER JOIN|
|---------------|:------------------------|

## INNER Join
INNER JOIN clause matches each row from the albums table with every row from the artists table based on the join condition (artists.ArtistId = albums.ArtistId) specified after the ON keyword. If the join condition evaluates to true (or 1), the columns of rows from both albums and artists tables are included in the result set.

*Who are the top 5 artists with the highest number of tracks to their credit?*

```sql
SELECT Name, count(Title) as TitleNum
FROM 
    albums
INNER JOIN artists 
    ON artists.ArtistId = albums.ArtistId
GROUP BY Name
ORDER BY count(Title) DESC
LIMIT 5
```
| :bulb:        | Observe that Name of artist and Title are not available on the same table|
|---------------|:------------------------|

## LEFT OUTER join

Let's try a new question:

*What are the 10 artists with the least number of albums?*

```sql
SELECT a.name, count (al.AlbumId) as AlbumCount
FROM artists a
INNER JOIN albums al ON al.ArtistId = a.ArtistId
GROUP BY a.name
ORDER BY count(al.AlbumId) ASC
LIMIT 20
```

| :warning:        | The last SQL statement is syntax wise correct. But is it semantically consistent? Remember a artist may or maynot have a album |
|---------------|:------------------------|

Let's try to understand the situation better with the following diagram:

![outer](https://www.sqlitetutorial.net/wp-content/uploads/2015/12/SQLite-Left-Join-Venn-Diagram.png)

- 13: Are the artists who have a album (yellow portion between 2 circles)
- 2 : Are the artists who have no albums! (left yellow portion)
- 5:  Would be albums with no artists. (right white portion) But in our case there ae no albums without a artist, therefore this is a 0 set

Therefore in oyr case our query needs to get us the album count across 13+2.
- INNER JOIN: Only retrieve result set for 13
- LEFT OUTER JOIN: Retrieves result set for (13+2) 
- RIGHT OUTER JOIN: Retrieves result set for (5+13)
- FULL OUTER JOIN: Retrieves result set for (5+2+13)

```sql
SELECT a.name, count (al.AlbumId) as AlbumCount
FROM artists a
LEFT JOIN albums al ON al.ArtistId = a.ArtistId
GROUP BY a.name
ORDER BY
count(al.AlbumId) ASC
LIMIT 20
```
The above query should return 20 rows of artists with 0 albums to their credit. Often these are called bottom performers

| :sparkler:        | Think through what you did for SET operations and JOIN operations. How do you think they compare when considering the artists attributes |
|---------------|:------------------------|

# WHERE Clause 
The WHERE clause is an optional clause of the SELECT statement. It appears after the FROM clause.
In this example, you add a WHERE clause to the SELECT statement to filter rows returned by the query. When evaluating a SELECT statement with a WHERE clause, SQLite uses the following steps:

- First, check the table in the FROM clause.
- Second, evaluate the conditions in the WHERE clause to get the rows that met these conditions.
- Third, make the final result set based on the rows in the previous step with columns in the SELECT clause.

Besides the SELECT statement, you can use the WHERE clause in the UPDATE and DELETE statements.

## SQLite comparison operators
A comparison operator tests if two expressions are the same. The following table illustrates the comparison operators that you can use to construct expressions:
|Operator |Meaning
|---------|-------|
|=	|Equal to
|<> or !=	|Not equal to
|<	|Less than
|>	|Greater than
|<=	|Less than or equal to
|>=	|Greater than or equal to

## SQLite logical operators
Logical operators allow you to test the truth of some expressions. A logical operator returns 1, 0, or a NULL value.
Notice that SQLite does not provide Boolean data type therefore 1 means TRUE, and 0 means FALSE.

The following table illustrates the SQLite logical operators:
|Operator	|Meaning|
|-----------|-------|
|ALL	|returns 1 if all expressions are 1.
|AND	|returns 1 if both expressions are 1, and 0 if one of the expressions is 0.
|ANY	|returns 1 if any one of a set of comparisons is 1.
|BETWEEN	|returns 1 if a value is within a range.
|EXISTS	|returns 1 if a subquery contains any rows.
|IN	|returns 1 if a value is in a list of values.
|LIKE	|returns 1 if a value matches a pattern
|NOT	|reverses the value of other operators such as NOT EXISTS, NOT IN, NOT BETWEEN, etc.
|OR	|returns true if either expression is 1

üìù: Try your hand at SQL

*Use the tracks table and provide tracknames that are from album id 4 with length of more than 215000 milliseconds and less than 12000000 bytes*

### IS NULL
NULL is special. It indicates that a piece of information is unknown or not applicable. For example, some songs may not have the songwriter information because we don‚Äôt know who wrote them. To store these unknown songwriters along with the songs in a database table, we must use NULL. NULL is not equal to anything even the number zero, an empty string, and so on. Especially, NULL is not equal to itself.

*Find all racks with no composers*

```sql
SELECT
    Name, 
    Composer
FROM
    tracks
WHERE
    Composer IS NULL
ORDER BY 
    Name; 
```

‚ö†Ô∏è: '= NULL' is incorrect syntax. It is always going to be IS NULL

As a corollary there is also a IS NOT NULL syntax. You may want to write the converse of the above statement

# Aggregate Functions
Aggregate functions operate on a set of rows and return a single result. Aggregate functions are often used in conjunction with GROUP BY and HAVING clauses in the SELECT statement.

SQLite provides the following aggregate functions:

- AVG() ‚Äì returns the average value of a group.
- COUNT() ‚Äì returns the number of rows that match a specified condition
- MAX() ‚Äì returns the maximum value in a group.
- MIN() ‚Äì returns the minimum value in a group
- SUM() ‚Äì returns the sum of values
- GROUP_CONCAT(expression, separator) ‚Äì returns a string that is the concatenation of all non-NULL values of the input expression separated by the separator.

Examples:
```sql
SELECT
    AlbumId,
    COUNT(TrackId) track_count
FROM
    tracks
GROUP BY
    AlbumId
ORDER BY
    track_count DESC;
```
*What is the number of tracks and total minutes for each albumid?*

```sql
SELECT
    AlbumId,
    COUNT(TrackId) track_count,
    SUM(Milliseconds) / 60000 Minutes
FROM
    tracks
GROUP BY
    AlbumId
ORDER BY
    track_count DESC;
```

*Find the tracks with the longest length of time*
```sql
SELECT
    TrackId,
    Name,
    Milliseconds
FROM
    tracks
WHERE 
    Milliseconds =   (
        SELECT
            MAX(Milliseconds)
        FROM
            tracks)
```
*Give me a list of all tracks on albumid= 10*
```sql
   SELECT
    GROUP_CONCAT(name, '| ')
FROM
    tracks
WHERE   
    AlbumId = 10;
```
# Subquery
A subquery is a SELECT statement nested in another statement. Typically, a subquery returns a single row as an atomic value, though it may return multiple rows for comparing values with the IN operator.
You can use a subquery in the SELECT, FROM, WHERE, and JOIN clauses.

## SQLite subquery in the WHERE clause example
You can use a simple subquery as a search condition. 
*Give me all the tracks in the album with the title  'Let There Be Rock'*

```sql
SELECT trackid,
       name,
       albumid
FROM tracks
WHERE albumid = (
   SELECT albumid
   FROM albums
   WHERE title = 'Let There Be Rock'
);
```
The subquery returns the id of the album with the title 'Let There Be Rock'. The query uses the equal operator (=) to compare albumid returned by the subquery with the  albumid in the tracks table.

If the subquery returns multiple values, you can use the IN operator to check for the existence of a single value against a set of value.
For example:-
*Who are the customers whose sales representatives are in Canada?*

```sql
SELECT customerid,
       firstname,
       lastname
  FROM customers
 WHERE supportrepid IN (
           SELECT employeeid
             FROM employees
            WHERE country = 'Canada'
       );
 ```
The subquery returns a list of ids of the employees who locate in Canada. The outer query uses the IN operator to find the customers who have the sales representative id in the list.

## SQLite subquery in the FROM clause example
Useful to apply aggregate functions to a column multiple times. 
*What is the average size across all albums?*
```sql
SELECT AVG(SUM(bytes) 
FROM tracks
GROUP BY albumid;
```
:warning: The above query won't do it as the sum needs to be applied at a different levels, first summed across all tracks ina a album and then averaged across all albums

```sql
SELECT
	AVG(album.size)
FROM
	(
		SELECT
			SUM(bytes) SIZE
		FROM
			tracks
		GROUP BY
			albumid
	) AS album;
```
:warning: Skipping correlated subquery as it is a slightly advanced topic

## EXISTS
The EXISTS operator is a logical operator that checks whether a subquery returns any row. In this syntax, the subquery is a SELECT statement that returns zero or more rows.
If the subquery returns one or more row, the EXISTS operator return true. Otherwise, the EXISTS operator returns false or NULL.
Note that if the subquery returns one row with NULL, the result of the EXISTS operator is still true because the result set contains one row with NULL.
To negate the EXISTS operator, you use the NOT EXISTS
*What is the list of CustomerId, name and company who have a invoice?*
```sql
SELECT
    CustomerId,
    FirstName,
    LastName,
    Company
FROM
    Customers c
WHERE
    EXISTS (
        SELECT 
            1 
        FROM 
            Invoices
        WHERE 
            CustomerId = c.CustomerId
    )
ORDER BY
    FirstName,
    LastName;
```

# String Functions

|Name|	Description|
|----|-------------|
|SUBSTR |Extract and returns a substring with a predefined length starting at a specified position in a source string|
|TRIM	|Return a copy of a string that has specified characters removed from the beginning and the end of a string.|
|LTRIM	|Return a copy of a string that has specified characters removed from the beginning of a string.|
|RTRIM	|Return a copy of a string that has specified characters removed from the end of a string.|
|LENGTH	|Return the number of characters in a string or the number of bytes in a BLOB.|
|REPLACE	|Return a copy of a string with each instance of a substring replaced by another substring.|
|UPPER	|Return a copy of a string with all of the characters converted to uppercase.|
|LOWER	|Return a copy of a string with all of the characters converted to lowercase.|
|INSTR	|Find a substring in a string and returns an integer indicating the position of the first occurrence of the substring.|
|Concatenation Operator ||	|Concatenate two strings into a single string.|

# DATE Manipulation
Often you may be asked to manipulate date ranges in SQL. Example:-
*Find me the count of invoices and the sum of the values of all invoices in Q1 2010*

```sql
select count(InvoiceId) as InvoiceCount, sum(Total) InvoiceDollar
from invoices
where InvoiceDate between '2010-01-01' and '2010-03-31'
```
| :memo:        | In this course the date and time functions use a subset of IS0-8601 date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns "YYYY-MM-DD HH:MM:SS".|
|---------------|:------------------------|

## DATE function

The date() function accepts a time string and zero or more modifiers as arguments. It returns a date string in this format: YYYY-MM-DD.

```sql
SELECT 
    DATE('now',
        'start of month',
        '+1 month',
        '-1 day')
```

The function works as follows:
- First, start of month is applied to the current date specified by the now time string so the result is the first day of the current month.
- Second, +1 month is applied to the first day of the current month that results on the first day of next month.
- Third, -1 day is applied to the first day of the next month which results in the last day of the previous month.

## strftime() function

Often you may need to extract specific parts of a date string and perform aggregation exercise. Example:-
*What are the number of in invoices and billed $ for USA every month and year?*

```sql
SELECT strftime('%Y-%m',InvoiceDate), count(InvoiceId), sum(Total)
from invoices
where BillingCountry= 'USA'
group by strftime('%Y-%m',InvoiceDate)
```

The strftime() function is used to format a datetime value based on a specified format. The format_string specifies the format for the datetime value specified by the time_string value.

The following table shows the complete list of valid markers for constructing format:

|Format|	Description|
|------|---------------|
|%d	|day of the month: 01-31|
|%f	|fractional seconds: SS.SSS|
|%H	|hour: 00-24|
|%j	|day of the year: 001-366|
|%J	|Julian day number|
|%m	|month: 01-12|
|%M	|minute: 00-59|
|%s	|seconds since 1970-01-01|
|%S	|seconds: 00-59|
|%w	|day of week 0-6 with Sunday==0|
|%W	|week of the year: 00-53
|%Y	|year: 0000-9999
